<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Abstract Art ‚Äî Working</title>
  <style>
    html,body { height:100%; margin:0; background: radial-gradient(circle at center, #03010f, #000); overflow:hidden; }
    #info { position: absolute; left: 12px; top: 12px; z-index: 10; color: #fff; font-family: sans-serif; }
    a { color: #88f; }
  </style>
</head>
<body>
  <div id="info">ü™ê 3D Abstract Art ‚Äî drag to orbit, scroll to zoom</div>

  <!-- Use module imports from unpkg (works well on GitHub Pages / local) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let shapes = [];

    init();
    animate();

    function init() {
      // Scene + camera
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x00000a);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
      camera.position.set(0, 20, 80);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.physicallyCorrectLights = true;
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(30, 50, 20);
      scene.add(dir);

      const rim = new THREE.PointLight(0x88bbff, 0.6, 200);
      rim.position.set(-40, -10, 40);
      scene.add(rim);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 20;
      controls.maxDistance = 300;

      // Ground-ish subtle grid (optional)
      const grid = new THREE.GridHelper(400, 40, 0x111122, 0x08080a);
      grid.material.opacity = 0.06;
      grid.material.transparent = true;
      scene.add(grid);

      // Materials & geometries
      const mats = [
        new THREE.MeshStandardMaterial({ color: 0xff6b6b, metalness: 0.7, roughness: 0.25 }),
        new THREE.MeshStandardMaterial({ color: 0x6bcf6b, metalness: 0.6, roughness: 0.2 }),
        new THREE.MeshStandardMaterial({ color: 0x4d96ff, metalness: 0.8, roughness: 0.25 }),
        new THREE.MeshStandardMaterial({ color: 0xc77dff, metalness: 0.9, roughness: 0.3 }),
      ];

      const geos = [
        new THREE.TorusGeometry(6, 1.6, 16, 100),
        new THREE.SphereGeometry(3.6, 32, 32),
        new THREE.BoxGeometry(6, 6, 6),
        new THREE.OctahedronGeometry(4, 0),
        new THREE.ConeGeometry(4, 8, 24),
        new THREE.TorusKnotGeometry(3.5, 0.8, 120, 16)
      ];

      // Create random shapes
      for (let i = 0; i < 28; i++) {
        const g = geos[Math.floor(Math.random() * geos.length)];
        const m = mats[Math.floor(Math.random() * mats.length)];
        const mesh = new THREE.Mesh(g, m);

        mesh.position.set(
          (Math.random() - 0.5) * 120,
          (Math.random() - 0.5) * 60,
          (Math.random() - 0.5) * 120
        );

        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        mesh.scale.setScalar(0.7 + Math.random() * 1.6);

        scene.add(mesh);
        shapes.push(mesh);
      }

      // subtle fog for depth
      scene.fog = new THREE.FogExp2(0x00000a, 0.0025);

      // handle resize
      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    function animate() {
      requestAnimationFrame(animate);
      // rotate shapes gently
      for (let i = 0; i < shapes.length; i++) {
        const s = shapes[i];
        s.rotation.x += 0.002 + (i % 3) * 0.0005;
        s.rotation.y += 0.003 + (i % 4) * 0.0006;
      }
      scene.rotation.y += 0.0008; // slow scene rotation
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
