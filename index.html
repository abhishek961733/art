<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image Puzzle Game (Embedded Photo)</title>
  <style>
    :root{--gap:6px}
    body{font-family:Inter, system-ui, -apple-system,Segoe UI, Roboto, "Helvetica Neue", Arial; background:#0f172a;color:#e6eef8;display:flex;align-items:flex-start;gap:24px;padding:28px}
    .panel{width:360px;min-height:200px;background:linear-gradient(180deg,#0b1220,#071022);border-radius:12px;padding:18px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    h1{font-size:18px;margin:0 0 12px}
    label{display:block;font-size:13px;margin:8px 0 6px;color:#bcd3ff}
    select,input[type=number]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{margin-top:10px;padding:10px 12px;border-radius:10px;border:0;background:#2563eb;color:white;font-weight:600;cursor:pointer}
    .status{margin-top:12px;font-size:13px;color:#b7c7ff}
    .board-wrap{flex:1;display:flex;align-items:center;justify-content:center}
    .board{background:#07102a;padding:var(--gap);border-radius:12px;display:grid;align-items:center;justify-items:center}
    .tile{touch-action:none;user-select:none;border-radius:6px;box-shadow:0 4px 10px rgba(2,6,23,0.6);cursor:pointer}
    .empty{background:transparent;cursor:default;box-shadow:none}
    .controls-row{display:flex;gap:8px;margin-top:10px}
    .small{padding:8px 10px;font-size:13px}
    .footer-note{font-size:12px;color:#93a6ff;margin-top:10px}
    @media (max-width:900px){body{flex-direction:column;align-items:stretch;padding:12px}.panel{width:100%}}
  </style>
</head>
<body>
  <div class="panel">
    <h1>Image Puzzle — Embedded Photo</h1>
    <label>Grid size</label>
    <select id="size">
      <option value="3">3 x 3 (easy)</option>
      <option value="4" selected>4 x 4 (classic)</option>
      <option value="5">5 x 5 (hard)</option>
      <option value="6">6 x 6 (very hard)</option>
    </select>

    <div class="controls-row">
      <button id="start">Create & Shuffle</button>
      <button id="shuffle" class="small">Reshuffle</button>
      <button id="solve" class="small">Show Solution</button>
    </div>

    <div class="status">
      <div>Moves: <span id="moves">0</span></div>
      <div>Time: <span id="timer">00:00</span></div>
      <div class="footer-note">Tip: Click/tap a tile next to the empty space to move it. “Show Solution” will reset to solved.</div>
    </div>
  </div>

  <div class="board-wrap">
    <div id="board" class="board" style="max-width:680px; max-height:680px; min-width:240px; min-height:240px;"></div>
  </div>

<script>
// Puzzle code starts here
const sizeSelect = document.getElementById('size');
const startBtn = document.getElementById('start');
const shuffleBtn = document.getElementById('shuffle');
const solveBtn = document.getElementById('solve');
const boardEl = document.getElementById('board');
const movesEl = document.getElementById('moves');
const timerEl = document.getElementById('timer');

let img = new Image();
img.src = 'https://pbs.twimg.com/profile_images/1950265537784926208/qbjSWMDP_400x400.jpg';

let cols = 4, rows = 4;
let tiles = [];
let emptyIndex = null;
let moves = 0;
let timerInterval = null;
let startTime = null;

function resetStatus(){
  moves = 0;
  movesEl.textContent = '0';
  stopTimer();
  timerEl.textContent = '00:00';
}
function startTimer(){
  stopTimer();
  startTime = Date.now();
  timerInterval = setInterval(()=>{
    const s = Math.floor((Date.now() - startTime)/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    timerEl.textContent = mm + ':' + ss;
  },250);
}
function stopTimer(){
  if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
}

function buildBoard(){
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
  boardEl.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  tiles = [];

  const boardRect = boardEl.getBoundingClientRect();
  const sizePx = Math.min(boardRect.width, boardRect.height);
  const tileSizePx = Math.floor((sizePx - (cols-1)*0)/cols);

  const imgW = img.naturalWidth, imgH = img.naturalHeight;
  const cw = Math.floor(imgW/cols), ch = Math.floor(imgH/rows);

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const idx = r*cols + c;
      const canvas = document.createElement('canvas');
      canvas.width = cw; canvas.height = ch;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, c*cw, r*ch, cw, ch, 0, 0, cw, ch);
      const dataURL = canvas.toDataURL();

      const tileEl = document.createElement('div');
      tileEl.className = 'tile';
      tileEl.style.width = '100%';
      tileEl.style.height = '100%';
      tileEl.style.backgroundImage = `url(${dataURL})`;
      tileEl.style.backgroundSize = 'cover';
      tileEl.style.backgroundPosition = 'center';
      tileEl.dataset.index = idx;

      const tileObj = { id: idx, correctPos: idx, currentPos: idx, el: tileEl };
      tiles.push(tileObj);

      tileEl.addEventListener('click', ()=> onTileClick(idx));
    }
  }

  // last tile is empty
  emptyIndex = tiles.length - 1;
  tiles[emptyIndex].el.style.visibility = 'hidden';
  tiles[emptyIndex].el.classList.add('empty');

  // append wrappers
  for(let i=0;i<tiles.length;i++){
    const wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100%';
    wrapper.style.overflow = 'hidden';
    wrapper.style.borderRadius = '6px';
    wrapper.appendChild(tiles[i].el);
    boardEl.appendChild(wrapper);
  }
}

function onTileClick(index){
  const tileIdx = tiles.findIndex(t => t.currentPos === index);
  if(tileIdx === -1) return;
  const tile = tiles[tileIdx];
  const target = tile.currentPos;
  const neighbors = getNeighbors(emptyIndex);
  if(neighbors.includes(target)){
    // swap
    const a = tile;
    const b = tiles.find(t=>t.currentPos === emptyIndex);
    const tmp = a.currentPos;
    a.currentPos = b.currentPos;
    b.currentPos = tmp;
    emptyIndex = target;

    moves++;
    movesEl.textContent = moves;
    if(!timerInterval) startTimer();
    renderTiles();
    if(checkSolved()){
      stopTimer();
      setTimeout(()=> alert(`Solved in ${moves} moves and ${timerEl.textContent}!`),200);
    }
  }
}

function getNeighbors(pos){
  const r = Math.floor(pos/cols), c = pos%cols;
  const neighbors = [];
  [[1,0],[-1,0],[0,1],[0,-1]].forEach(d=>{
    const nr = r + d[0], nc = c + d[1];
    if(nr>=0 && nr<rows && nc>=0 && nc<cols) neighbors.push(nr*cols + nc);
  });
  return neighbors;
}

function renderTiles(){
  for(let pos=0; pos<tiles.length; pos++){
    const tileObj = tiles.find(t=>t.currentPos === pos);
    const wrapper = boardEl.children[pos];
    wrapper.innerHTML = '';
    if(tileObj){
      wrapper.appendChild(tileObj.el);
      if(tileObj.currentPos === emptyIndex){
        tileObj.el.style.visibility = 'hidden';
        tileObj.el.classList.add('empty');
      } else {
        tileObj.el.style.visibility = 'visible';
        tileObj.el.classList.remove('empty');
      }
    }
  }
}

function shuffleByRandomMoves(count=200){
  for(let i=0;i<count;i++){
    const neigh = getNeighbors(emptyIndex);
    const pick = neigh[Math.floor(Math.random()*neigh.length)];
    const tileObj = tiles.find(t=>t.currentPos === pick);
    if(tileObj){
      const tmp = tileObj.currentPos;
      tileObj.currentPos = emptyIndex;
      tiles.find(t=>t.currentPos===emptyIndex && t!==tileObj).currentPos = tmp;
      emptyIndex = pick;
    }
  }
}

function checkSolved(){
  return tiles.every(t => t.currentPos === t.correctPos);
}

// button events
startBtn.addEventListener('click', ()=>{
  cols = rows = parseInt(sizeSelect.value,10);
  resetStatus();
  img.onload = ()=>{
    buildBoard();
    shuffleByRandomMoves(250);
    const emp = tiles.find(t=>t.correctPos === tiles.length-1);
    emptyIndex = emp.currentPos;
    renderTiles();
  };
  // if already loaded, trigger onload manually
  if(img.complete) img.onload();
});

shuffleBtn.addEventListener('click', ()=>{
  if(tiles.length===0) return;
  shuffleByRandomMoves(200);
  const emp = tiles.find(t=>t.correctPos === tiles.length-1);
  emptyIndex = emp.currentPos;
  moves = 0;
  movesEl.textContent = '0';
  stopTimer();
  timerEl.textContent = '00:00';
  renderTiles();
});

solveBtn.addEventListener('click', ()=>{
  if(tiles.length===0) return;
  tiles.forEach(t=> t.currentPos = t.correctPos);
  emptyIndex = tiles.length-1;
  moves = 0;
  movesEl.textContent = '0';
  stopTimer();
  timerEl.textContent = '00:00';
  renderTiles();
});

// initial placeholder
function makePlaceholder(){
  boardEl.style.width = 'min(68vmin,680px)';
  boardEl.style.height = 'min(68vmin,680px)';
  boardEl.innerHTML = '';
  const pCols = 4, pRows = 4;
  boardEl.style.gridTemplateColumns = `repeat(${pCols}, 1fr)`;
  boardEl.style.gridTemplateRows = `repeat(${pRows}, 1fr)`;
  for(let i=0;i<pCols*pRows;i++){
    const wrapper = document.createElement('div');
    wrapper.style.width='100%'; wrapper.style.height='100%';
    wrapper.style.borderRadius='6px';
    wrapper.style.background='linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01))';
    wrapper.style.backdropFilter='blur(2px)';
    boardEl.appendChild(wrapper);
  }
}
makePlaceholder();

window.addEventListener('resize', ()=>{
  if(tiles.length===0) return;
  setTimeout(()=>{
    const currentPositions = tiles.map(t=>t.currentPos);
    buildBoard();
    tiles.forEach((t,i)=> t.currentPos = currentPositions[i]);
    const emp = tiles.find(t=>t.correctPos === tiles.length-1);
    emptyIndex = emp.currentPos;
    renderTiles();
  },200);
});
</script>
</body>
</html>
